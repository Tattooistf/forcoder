并查集
    关键点：基础点是find和merge两个函数，前者除了查根之外，还可以考虑路径裁剪，直接指向根节点。
    扩展解题方法：多维度的并查集，利用多维度解决敌人的敌人就是朋友的问题，扩展一个数组存储敌人的维度。
    常见题目有强盗团个数统计、敌人的敌人是朋友、ABC同类物种

前缀和
    以前理解的前缀和主要是sum的含义，今天发现深层次的思路和题目还不少，比如二维前缀和、差分数组
    利用前缀和和差分数组求解区域和，或者其他区域性操作。之前也见过不少类似的题目，其中最为典型的就是差分数组上下车的问题。
    差分数组特征区域数据的变化可以只呈现在一个数组成员中。

双指针
    典型题目，最小盛水容器
    挺好的题型总结：https://www.cnblogs.com/codingstory/p/11334827.html

前缀树
    根节点不存放数据，每个节点有个标志表示该节点是否算入构成数据的一部分。
    典型数据结构，26大小的数组+flag标记
    典型场景：
        单词频次统计。
        字符串匹配。
        字符串字典序排序。
        前缀匹配，比如一些搜索框的自动提示。
数组
    数组典型运算
        有序数组查找target，可以通过从下到上，先找行再找列做到O(m+n)

双向队列
    头部和尾部都可以入队和出队
        主要用于计算windows内最大值的集合；头每次都是最大值，尾部进行添加删除；小技巧，队列存放i，能方便计算windows边界

优先级队列
    后面补充

链表
    常见解题思路：创建哨兵节点、快慢指针（找环、倒数K节点）、O1删除节点（后节点覆盖当前节点）

其他的思路总结
    https://segmentfault.com/a/1190000021762090

参考解释：
【前缀和数组】

定义

给定一个数组A[n]，则其前缀和数组有B[m]=A[0]+A[1]+…+A[m]。

例：

A[]={5,6,7,9,3,4}

B[]={5,11,18,27,30,34}

B[0]=A[0]

B[1]=A[0]+A[1]

B[2]=A[0]+A[1]+A[2]

B[3]=A[0]+A[1]+A[2]+A[3]

B[4]=A[0]+A[1]+A[2]+A[3]+A[4]

B[5]=A[0]+A[1]+A[2]+A[3]+A[4]+A[5]

【差分数组】

定义

给定数组A[n]，则其差分数组B[n]=A[n]-A[n-1] n>0，且B[0]=A[n]-0。

且有一下特性：

特性一
A[n]=B[0]+B[1]+…+B[n]

A[n]=（A[0]-0）+（A[1]-A[0] ）+（A[2]-A[1] ）+…+A[n]-A[n-1]

A[n]=A[n]

特性二
B[n]的前缀和数组sumB[n]=B[0]+B[1]+…+B[n]

由特性一可得sumb[n]=（A[0]-0）+（A[1]-A[0] ）+（A[2]-A[1] ）+…+A[n]-A[n-1] =A[n]

即当B[n]为A[n]的差分数组时，A[n]为B[n]的前缀和数组。

适用场景

主要可以应用到快速处理区间加减操作、查询区间和问题

比如，

1.给定A[]，在区间[i,j]的所有数组均加value，求操作后的A[]。

2.给定A[]，求区间[i,j]的和，

把序列A的区间【l，r】加d，其差分序列的变化为Bl加d，Br+1减d，其他位置不变，把原序列上的区间操作转化为差分序列上的单点操作进行计算

https://mp.weixin.qq.com/s?__biz=MzAxODQxMDM0Mw==&mid=2247484488&amp;idx=1&amp;sn=848f76e86fce722e70e265d0c6f84dc3&source=41#wechat_redirect
https://www.cnblogs.com/LMCC1108/p/10753451.html 关注二维的最优解求解