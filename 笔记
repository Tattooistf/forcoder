并查集
    关键点：基础点是find和merge两个函数，前者除了查根之外，还可以考虑路径裁剪，直接指向根节点。
    扩展解题方法：多维度的并查集，利用多维度解决敌人的敌人就是朋友的问题，扩展一个数组存储敌人的维度。
    常见题目有强盗团个数统计、敌人的敌人是朋友、ABC同类物种

前缀和
    以前理解的前缀和主要是sum的含义，今天发现深层次的思路和题目还不少，比如二维前缀和、差分数组
    利用前缀和和差分数组求解区域和，或者其他区域性操作。之前也见过不少类似的题目，其中最为典型的就是差分数组上下车的问题。
    差分数组特征区域数据的变化可以只呈现在一个数组成员中。

双指针
    典型题目，最小盛水容器
    挺好的题型总结：https://www.cnblogs.com/codingstory/p/11334827.html

前缀树
    根节点不存放数据，每个节点有个标志表示该节点是否算入构成数据的一部分。
    典型数据结构，26大小的数组+flag标记
    典型场景：
        单词频次统计。
        字符串匹配。
        字符串字典序排序。
        前缀匹配，比如一些搜索框的自动提示。
数组
    数组典型运算
        有序数组查找target，可以通过从下到上，先找行再找列做到O(m+n)

双向队列
    头部和尾部都可以入队和出队
        主要用于计算windows内最大值的集合；头每次都是最大值，尾部进行添加删除；小技巧，队列存放i，能方便计算windows边界

优先级队列
    后面补充

链表
    常见解题思路：创建哨兵节点、快慢指针（找环、倒数K节点）、O1删除节点（后节点覆盖当前节点）

推排序
    各归各位，假定i 个数字没有按照顺序放入数组，那就按照下标直接存储，最后寻找该位置没存储上对应值的点就是求解点；如果都不存在则最大值+1
    缺失的数字：https://www.cxyxiaowu.com/7030.html
回溯算法
    主要解决题型：子集、组合、排列
    典型模版如下，先选择递归然后再回退
    def backtrack(路径, 选择列表):
    if 满足结束条件:
        result.add(路径)
        return
    for 选择 in 选择列表:
        做选择
        backtrack(路径, 选择列表)
        撤销选择
    以上，就是排列组合和子集三个问题的解法，总结一下：

    1、子集问题可以利用数学归纳思想，假设已知一个规模较小的问题的结果，思考如何推导出原问题的结果。也可以用回溯算法，要用 start 参数排除已选择的数字。
    2、组合问题利用的是回溯思想，结果可以表示成树结构，我们只要套用回溯算法模板即可，关键点在于要用一个 start 排除已经选择过的数字。
    3、排列问题是回溯思想，也可以表示成树结构套用算法模板，关键点在于使用 contains 方法排除已经选择的数字，前文有详细分析，这里主要是和组合问题作对比。
位运算
    n & (n-1)计算1出现的次数
    唯一出现一次的数字，异或^操作
    A变成B需要的步骤，异或后取1的个数
    负数变正整数，~a+1
    利用位表示是否选取，实现子集的计算
    每一位出现的次数，来计算只出现一次的数字
    利用异或后选择为1的位域，来将数组分为2个，从而求得只出现1次的2个数字
    
其他的思路总结
    https://segmentfault.com/a/1190000021762090

参考解释：
【前缀和数组】

定义

给定一个数组A[n]，则其前缀和数组有B[m]=A[0]+A[1]+…+A[m]。

例：

A[]={5,6,7,9,3,4}

B[]={5,11,18,27,30,34}

B[0]=A[0]

B[1]=A[0]+A[1]

B[2]=A[0]+A[1]+A[2]

B[3]=A[0]+A[1]+A[2]+A[3]

B[4]=A[0]+A[1]+A[2]+A[3]+A[4]

B[5]=A[0]+A[1]+A[2]+A[3]+A[4]+A[5]

【差分数组】

定义

给定数组A[n]，则其差分数组B[n]=A[n]-A[n-1] n>0，且B[0]=A[n]-0。

且有一下特性：

特性一
A[n]=B[0]+B[1]+…+B[n]

A[n]=（A[0]-0）+（A[1]-A[0] ）+（A[2]-A[1] ）+…+A[n]-A[n-1]

A[n]=A[n]

特性二
B[n]的前缀和数组sumB[n]=B[0]+B[1]+…+B[n]

由特性一可得sumb[n]=（A[0]-0）+（A[1]-A[0] ）+（A[2]-A[1] ）+…+A[n]-A[n-1] =A[n]

即当B[n]为A[n]的差分数组时，A[n]为B[n]的前缀和数组。

适用场景

主要可以应用到快速处理区间加减操作、查询区间和问题

比如，

1.给定A[]，在区间[i,j]的所有数组均加value，求操作后的A[]。

2.给定A[]，求区间[i,j]的和，

把序列A的区间【l，r】加d，其差分序列的变化为Bl加d，Br+1减d，其他位置不变，把原序列上的区间操作转化为差分序列上的单点操作进行计算

https://mp.weixin.qq.com/s?__biz=MzAxODQxMDM0Mw==&mid=2247484488&amp;idx=1&amp;sn=848f76e86fce722e70e265d0c6f84dc3&source=41#wechat_redirect
https://www.cnblogs.com/LMCC1108/p/10753451.html 关注二维的最优解求解