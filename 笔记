并查集
    关键点：基础点是find和merge两个函数，前者除了查根之外，还可以考虑路径裁剪，直接指向根节点。(路径裁剪有树深度方法和负数表示节点数的方法)
    扩展解题方法：多维度的并查集，利用多维度解决敌人的敌人就是朋友的问题，扩展一个数组存储敌人的维度。
    常见题目有强盗团个数统计、敌人的敌人是朋友、ABC同类物种

前缀和
    以前理解的前缀和主要是sum的含义，今天发现深层次的思路和题目还不少，比如二维前缀和、差分数组
    利用前缀和和差分数组求解区域和，或者其他区域性操作。之前也见过不少类似的题目，其中最为典型的就是差分数组上下车的问题。
    差分数组特征区域数据的变化可以只呈现在一个数组成员中。

双指针
    典型题目，最小盛水容器
    挺好的题型总结：https://www.cnblogs.com/codingstory/p/11334827.html
滑动窗口
    遇到子串问题首先想到滑动窗口，最小覆盖子串，无重复字符的最长子串
    另外一个思路供参考：https://leetcode-cn.com/problems/corporate-flight-bookings/solution/xi-fa-dai-ni-xue-suan-fa-yi-ci-gao-ding-qian-zhu-5/

前缀树
    根节点不存放数据，每个节点有个标志表示该节点是否算入构成数据的一部分。
    典型数据结构，26大小的数组+flag标记
    典型场景：
        单词频次统计。
        字符串匹配。
        字符串字典序排序。
        前缀匹配，比如一些搜索框的自动提示。
数组
    数组典型运算
        有序数组查找target，可以通过从下到上，先找行再找列做到O(m+n)

双向队列/单调队列
    头部和尾部都可以入队和出队
        主要用于计算windows内最大值的集合；头每次都是最大值，尾部进行添加删除；小技巧，队列存放i，能方便计算windows边界

优先级队列
    后面补充
堆
    push从低到高一层挪位置，pop返回1位置的值，有固定套路（先判断2*i和2*i+1的大小，然后再与最值进行比较挪位置）

链表
    常见解题思路：创建哨兵节点、快慢指针（找环、倒数K节点）、O1删除节点（后节点覆盖当前节点）

堆排序
    各归各位，假定i 个数字没有按照顺序放入数组，那就按照下标直接存储，最后寻找该位置没存储上对应值的点就是求解点；如果都不存在则最大值+1
    缺失的数字：https://www.cxyxiaowu.com/7030.html
单调栈
    当前项向左找第一个比自己大的位置 —— 从左向右维护一个单调递减栈
    当前项向左找第一个比自己小的位置 —— 从左向右维护一个单调递增栈
    当前项向右找第一个比自己大的位置 —— 从右向左维护一个单调递减栈
    当前项向右找第一个比自己小的位置 —— 从右向左维护一个单调递增栈
回溯算法
    主要解决题型：子集、组合、排列
    典型模版如下，先选择递归然后再回退
    def backtrack(路径, 选择列表):
    if 满足结束条件:
        result.add(路径)
        return
    for 选择 in 选择列表:
        做选择
        backtrack(路径, 选择列表)
        撤销选择
    以上，就是排列组合和子集三个问题的解法，总结一下：

    1、子集问题可以利用数学归纳思想，假设已知一个规模较小的问题的结果，思考如何推导出原问题的结果。也可以用回溯算法，要用 start 参数排除已选择的数字。
    2、组合问题利用的是回溯思想，结果可以表示成树结构，我们只要套用回溯算法模板即可，关键点在于要用一个 start 排除已经选择过的数字。
    3、排列问题是回溯思想，也可以表示成树结构套用算法模板，关键点在于使用 contains 方法排除已经选择的数字，前文有详细分析，这里主要是和组合问题作对比。

    字典树或前缀树+DFS（index+len）是字符串拆分最基本的解题方法
位运算
    n & (n-1)计算1出现的次数
    唯一出现一次的数字，异或^操作
    A变成B需要的步骤，异或后取1的个数
    负数变正整数，~a+1
    利用位表示是否选取，实现子集的计算
    每一位出现的次数，来计算只出现一次的数字
    利用异或后选择为1的位域，来将数组分为2个，从而求得只出现1次的2个数字
拓扑排序
    有向图的输出，有两种思路：1、出入度，每次都输出入度为零的，队列的方式，思路类似BFS；2、DFS遍历，先存储最后的节点；最后倒序输出；增加visit数组
动态规划
    常见的背包问题有1、组合问题。2、True、False问题。3、最大最小问题。
    我在大神整理的基础上，又做了细分的整理。分为三类。
    1、组合问题：
    2、True、False问题：
    3、最大最小问题：

    组合问题公式
        dp[i] += dp[i-num]
    True、False问题公式
        dp[i] = dp[i] or dp[i-num]
    最大最小问题公式
    dp[i] = min(dp[i], dp[i-num]+1)或者dp[i] = max(dp[i], dp[i-num]+1)

    最长重复子序列LCS、最长升序子序列LIS
    最长回文子串、最长回文子序列

    背包总结：
        首先是背包分类的模板：
        1、0/1背包：外循环nums,内循环target,target倒序且target>=nums[i];
        2、完全背包：外循环nums,内循环target,target正序且target>=nums[i];
        3、组合背包：外循环target,内循环nums,target正序且target>=nums[i];
        4、分组背包：这个比较特殊，需要三重循环：外循环背包bags,内部两层循环根据题目的要求转化为1,2,3三种背包类型的模板

        然后是问题分类的模板：
        1、最值问题: dp[i] = max/min(dp[i], dp[i-nums]+1)或dp[i] = max/min(dp[i], dp[i-num]+nums);
        2、存在问题(bool)：dp[i]=dp[i]||dp[i-num];
        3、组合问题：dp[i]+=dp[i-num];

链接：https://leetcode-cn.com/problems/combination-sum-iv/solution/xi-wang-yong-yi-chong-gui-lu-gao-ding-bei-bao-wen-/

后缀数组
    后缀数组法：求解最长重复子串；将字符串所有的后缀字符串存放在一个数组里，然后进行排序，遍历数组，寻找相邻两个字符串的最长公共前缀子串即为字符串的最长重复子串。

其他的思路总结
    https://segmentfault.com/a/1190000021762090

扑克牌分堆，二分查找法，解决升序子序列问题

参考解释：
【前缀和数组】

定义

给定一个数组A[n]，则其前缀和数组有B[m]=A[0]+A[1]+…+A[m]。

例：

A[]={5,6,7,9,3,4}

B[]={5,11,18,27,30,34}

B[0]=A[0]

B[1]=A[0]+A[1]

B[2]=A[0]+A[1]+A[2]

B[3]=A[0]+A[1]+A[2]+A[3]

B[4]=A[0]+A[1]+A[2]+A[3]+A[4]

B[5]=A[0]+A[1]+A[2]+A[3]+A[4]+A[5]

【差分数组】

定义

给定数组A[n]，则其差分数组B[n]=A[n]-A[n-1] n>0，且B[0]=A[n]-0。

且有一下特性：

特性一
A[n]=B[0]+B[1]+…+B[n]

A[n]=（A[0]-0）+（A[1]-A[0] ）+（A[2]-A[1] ）+…+A[n]-A[n-1]

A[n]=A[n]

特性二
B[n]的前缀和数组sumB[n]=B[0]+B[1]+…+B[n]

由特性一可得sumb[n]=（A[0]-0）+（A[1]-A[0] ）+（A[2]-A[1] ）+…+A[n]-A[n-1] =A[n]

即当B[n]为A[n]的差分数组时，A[n]为B[n]的前缀和数组。

适用场景

主要可以应用到快速处理区间加减操作、查询区间和问题

比如，

1.给定A[]，在区间[i,j]的所有数组均加value，求操作后的A[]。

2.给定A[]，求区间[i,j]的和，

把序列A的区间【l，r】加d，其差分序列的变化为Bl加d，Br+1减d，其他位置不变，把原序列上的区间操作转化为差分序列上的单点操作进行计算

https://mp.weixin.qq.com/s?__biz=MzAxODQxMDM0Mw==&mid=2247484488&amp;idx=1&amp;sn=848f76e86fce722e70e265d0c6f84dc3&source=41#wechat_redirect
https://www.cnblogs.com/LMCC1108/p/10753451.html 关注二维的最优解求解